"""
title: 尽量减少恶意软件的传播
writer: m14
date: 2024.4.16
key：DFS，状态机处理交叉感染
example:
输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1,2]
输出：2
thinking：
给出了一个由 n 个节点组成的网络，用 n × n 个邻接矩阵图 graph 表示。在节点网络中，当 graph[i][j] = 1 时，表示节点 i 能够直接连接到另一个节点 j。 
一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
如果从 initial 中移除某一节点能够最小化 M(initial)， 返回该节点。如果有多个节点满足条件，就返回索引最小的节点。
请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后仍有可能因恶意软件传播而受到感染。
"""



class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        if not initial:
            return 0

        def DFS(i, path):
            nonlocal node_id
            if node_id != -2 and i in initial:
                node_id = i if node_id == -1 else -2
            if node_id == -2:
                # if with a cross inflection, to close DFS
                return
            for idx, j in enumerate(graph[i]):
                if j == 1 and idx not in path:
                    path.add(idx)
                    DFS(idx, path)


        min_node = -1
        max_size = 0
        for item in initial:
            path = set([item])
            node_id = -1  # as a state machine
            DFS(item, path)

            if node_id >= 0 and (len(path) > max_size or len(path) == max_size and node_id < min_node):
                min_node = node_id
                max_size = len(path)
        
        return min(initial) if min_node < 0 else min_node
